using System;using System.Threading.Tasks;using NUnit.Framework;using TinyUpdate.Core.Logging;namespace TinyUpdate.Core.Tests.Logging{    [NonParallelizable]    // ReSharper disable once InconsistentNaming    public abstract class ILoggingTest<TLogger, TBuilder>         where TLogger : ILogging        where TBuilder : LoggingBuilder    {        protected TLogger Logger;        private readonly TBuilder _builder;        protected ILoggingTest(TBuilder builder)        {            _builder = builder;            Logger = (TLogger)builder.CreateLogger("Test-Log");        }        [Test]        public async Task LogCorrectlyOnGlobalTrace()        {            Logger.LogLevel = null;            LoggingCreator.GlobalLevel = LogLevel.Trace;            await TestLogging_Output(() => Logger.Debug("Test"));            await TestLogging_Output(() => Logger.Information("Test"));            await TestLogging_Output(() => Logger.Warning("Test"));            await TestLogging_Output(() => Logger.Error("Test"));            await TestLogging_Output(() => Logger.Error(new Exception()));        }        [Test]        public async Task LogCorrectlyOnGlobalInfo()        {            Logger.LogLevel = null;            LoggingCreator.GlobalLevel = LogLevel.Info;            await TestLogging_NoOutput(() => Logger.Debug("Test"));            await TestLogging_Output(() => Logger.Information("Test"));            await TestLogging_Output(() => Logger.Warning("Test"));            await TestLogging_Output(() => Logger.Error("Test"));            await TestLogging_Output(() => Logger.Error(new Exception()));        }        [Test]        public async Task LogCorrectlyOnGlobalWarn()        {            Logger.LogLevel = null;            LoggingCreator.GlobalLevel = LogLevel.Warn;            await TestLogging_NoOutput(() => Logger.Debug("Test"));            await TestLogging_NoOutput(() => Logger.Information("Test"));            await TestLogging_Output(() => Logger.Warning("Test"));            await TestLogging_Output(() => Logger.Error("Test"));            await TestLogging_Output(() => Logger.Error(new Exception()));        }                [Test]        public async Task LogCorrectlyOnGlobalError()        {            Logger.LogLevel = null;            LoggingCreator.GlobalLevel = LogLevel.Error;            await TestLogging_NoOutput(() => Logger.Debug("Test"));            await TestLogging_NoOutput(() => Logger.Information("Test"));            await TestLogging_NoOutput(() => Logger.Warning("Test"));            await TestLogging_Output(() => Logger.Error("Test"));            await TestLogging_Output(() => Logger.Error(new Exception()));        }        //NOTE: We do 'LoggingCreator.GlobalLevel = LogLevel.Error;' here because it should ignore the GlobalLevel and go by it's log level        [Test]        public async Task LogCorrectlyOnTrace()        {            Logger.LogLevel = LogLevel.Trace;            LoggingCreator.GlobalLevel = LogLevel.Error;            await TestLogging_Output(() => Logger.Debug("Test"));            await TestLogging_Output(() => Logger.Information("Test"));            await TestLogging_Output(() => Logger.Warning("Test"));            await TestLogging_Output(() => Logger.Error("Test"));            await TestLogging_Output(() => Logger.Error(new Exception()));        }        [Test]        public async Task LogCorrectlyOnInfo()        {            Logger.LogLevel = LogLevel.Info;            LoggingCreator.GlobalLevel = LogLevel.Error;            await TestLogging_NoOutput(() => Logger.Debug("Test"));            await TestLogging_Output(() => Logger.Information("Test"));            await TestLogging_Output(() => Logger.Warning("Test"));            await TestLogging_Output(() => Logger.Error("Test"));            await TestLogging_Output(() => Logger.Error(new Exception()));        }        [Test]        public async Task LogCorrectlyOnWarn()        {            Logger.LogLevel = LogLevel.Warn;            LoggingCreator.GlobalLevel = LogLevel.Error;            await TestLogging_NoOutput(() => Logger.Debug("Test"));            await TestLogging_NoOutput(() => Logger.Information("Test"));            await TestLogging_Output(() => Logger.Warning("Test"));            await TestLogging_Output(() => Logger.Error("Test"));            await TestLogging_Output(() => Logger.Error(new Exception()));        }                [Test]        public async Task LogCorrectlyOnError()        {            Logger.LogLevel = LogLevel.Error;            LoggingCreator.GlobalLevel = LogLevel.Error;            await TestLogging_NoOutput(() => Logger.Debug("Test"));            await TestLogging_NoOutput(() => Logger.Information("Test"));            await TestLogging_NoOutput(() => Logger.Warning("Test"));            await TestLogging_Output(() => Logger.Error("Test"));            await TestLogging_Output(() => Logger.Error(new Exception()));        }        [Test]        public void CreateMultipleLoggers()        {            var redoTest = true;            LoggingCreator.GlobalLevel = LogLevel.Trace;            while (true)            {                var logger1 = _builder.CreateLogger("Test");                var logger2 = _builder.CreateLogger("Test");                var logger3 = _builder.CreateLogger("Test");                logger1.Debug("Testing");                logger2.Debug("Testing");                logger3.Debug("Testing");                //Also disposable the loggers if they exist,                //we might crash when we try to cleanup                if (logger1 is IDisposable logger1D)                {                    logger1D.Dispose();                    ((IDisposable)logger2).Dispose();                    ((IDisposable)logger3).Dispose();                }                //and try the test again, we might crash if                //we remake the loggers                if (redoTest)                {                    redoTest = false;                    continue;                }                break;            }        }        [Test]        public void CreateAndDisposeMultipleLogs()        {            //Check that this is a IDisposable            if (typeof(TBuilder).GetInterface(nameof(IDisposable)) == null)            {                Assert.Ignore("{0} doesn't have IDisposable, can't run this test", _loggerName);            }                        LoggingCreator.GlobalLevel = LogLevel.Trace;            var logger1 = _builder.CreateLogger("Test");            var logger2 = _builder.CreateLogger("Test");            var logger3 = _builder.CreateLogger("Test");                        logger1.Debug("Test123");            logger2.Debug("Test123");            logger3.Debug("Test123");            ((IDisposable)logger3).Dispose();                        logger1.Debug("Test12");            logger2.Debug("Test12");            ((IDisposable)logger2).Dispose();                        logger1.Debug("Test12");            ((IDisposable)logger1).Dispose();        }        //TODO: Make sure that the logger is thread safe        //This will also indirectly test if we don't crash when doing this        [Test]        public async Task PropertiesFormatCorrectly()        {            LoggingCreator.GlobalLevel = LogLevel.Trace;            Logger.LogLevel = null;                        const string testMessage = "This is a {0} which should show 'true' in the brackets ({1}) and was made by {2}";            var objects = new object[] { "message", true, _loggerName };            var expectedResult = $"This is a message which should show 'true' in the brackets (True) and was made by {_loggerName}";            /*On these checks we do Contains as the logger might add it's own content              which is fine, we just want to make sure the message part is done correctly*/            var debugMessage = await WaitForLog(() => Logger.Debug(testMessage, objects));            Assert.True(debugMessage.Contains(expectedResult), "We didn't get the expected result but {0}", debugMessage);                        var infoMessage = await WaitForLog(() => Logger.Information(testMessage, objects));            Assert.True(infoMessage.Contains(expectedResult), "We didn't get the expected result but {0}", infoMessage);                        var warnMessage = await WaitForLog(() => Logger.Warning(testMessage, objects));            Assert.True(warnMessage.Contains(expectedResult), "We didn't get the expected result but {0}", warnMessage);                        var errorMessage = await WaitForLog(() => Logger.Error(testMessage, objects));            Assert.True(errorMessage.Contains(expectedResult), "We didn't get the expected result but {0}", errorMessage);                        //The logger deals with the exception overload so we need it to check it            await TestExceptionOverload(objects);        }        protected abstract Task TestExceptionOverload(object props);                protected abstract Task<string> WaitForLog(Action action);        protected abstract Task<bool> DoesLogOutput(Action action);        private readonly string _loggerName = typeof(TLogger).FullName!;        private async Task TestLogging_Output(Action action)        {            Assert.True(                await DoesLogOutput(action), "{0} should of outputted but it didn't (Global Level: {1}, Logger Level: {2})", _loggerName, LoggingCreator.GlobalLevel, Logger.LogLevel);        }        private async Task TestLogging_NoOutput(Action action)        {            Assert.False(                await DoesLogOutput(action), "{0} shouldn't of outputted but it did (Global Level: {1}, Logger Level: {2})", _loggerName, LoggingCreator.GlobalLevel, Logger.LogLevel);        }    }}