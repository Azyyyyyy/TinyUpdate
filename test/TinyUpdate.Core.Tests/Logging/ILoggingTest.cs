using System;using NUnit.Framework;using TinyUpdate.Core.Logging;namespace TinyUpdate.Core.Tests.Logging{    public abstract class ILoggingTest<T> where T : ILogging    {        private T _logger;        protected ILoggingTest(T logger)        {            _logger = logger;        }        [Test]        [NonParallelizable]        public void LogCorrectlyOnGlobalTrace()        {            _logger.LogLevel = null;            LoggingCreator.GlobalLevel = LogLevel.Trace;            TestLogging_Output(() => _logger.Debug("Test"));            TestLogging_Output(() => _logger.Information("Test"));            TestLogging_Output(() => _logger.Warning("Test"));            TestLogging_Output(() => _logger.Error("Test"));        }        [Test]        [NonParallelizable]        public void LogCorrectlyOnGlobalInfo()        {            _logger.LogLevel = null;            LoggingCreator.GlobalLevel = LogLevel.Info;            TestLogging_NoOutput(() => _logger.Debug("Test"));            TestLogging_Output(() => _logger.Information("Test"));            TestLogging_Output(() => _logger.Warning("Test"));            TestLogging_Output(() => _logger.Error("Test"));        }        [Test]        [NonParallelizable]        public void LogCorrectlyOnGlobalWarn()        {            _logger.LogLevel = null;            LoggingCreator.GlobalLevel = LogLevel.Warn;            TestLogging_NoOutput(() => _logger.Debug("Test"));            TestLogging_NoOutput(() => _logger.Information("Test"));            TestLogging_Output(() => _logger.Warning("Test"));            TestLogging_Output(() => _logger.Error("Test"));        }                [Test]        [NonParallelizable]        public void LogCorrectlyOnGlobalError()        {            _logger.LogLevel = null;            LoggingCreator.GlobalLevel = LogLevel.Error;            TestLogging_NoOutput(() => _logger.Debug("Test"));            TestLogging_NoOutput(() => _logger.Information("Test"));            TestLogging_NoOutput(() => _logger.Warning("Test"));            TestLogging_Output(() => _logger.Error("Test"));        }        //NOTE: We do 'LoggingCreator.GlobalLevel = LogLevel.Error;' here because it should ignore the GlobalLevel and go by it's log level        [Test]        [NonParallelizable]        public void LogCorrectlyOnTrace()        {            _logger.LogLevel = LogLevel.Trace;            LoggingCreator.GlobalLevel = LogLevel.Error;            TestLogging_Output(() => _logger.Debug("Test"));            TestLogging_Output(() => _logger.Information("Test"));            TestLogging_Output(() => _logger.Warning("Test"));            TestLogging_Output(() => _logger.Error("Test"));        }        [Test]        [NonParallelizable]        public void LogCorrectlyOnInfo()        {            _logger.LogLevel = LogLevel.Info;            LoggingCreator.GlobalLevel = LogLevel.Error;            TestLogging_NoOutput(() => _logger.Debug("Test"));            TestLogging_Output(() => _logger.Information("Test"));            TestLogging_Output(() => _logger.Warning("Test"));            TestLogging_Output(() => _logger.Error("Test"));        }        [Test]        [NonParallelizable]        public void LogCorrectlyOnWarn()        {            _logger.LogLevel = LogLevel.Warn;            LoggingCreator.GlobalLevel = LogLevel.Error;            TestLogging_NoOutput(() => _logger.Debug("Test"));            TestLogging_NoOutput(() => _logger.Information("Test"));            TestLogging_Output(() => _logger.Warning("Test"));            TestLogging_Output(() => _logger.Error("Test"));        }                [Test]        [NonParallelizable]        public void LogCorrectlyOnError()        {            _logger.LogLevel = LogLevel.Error;            LoggingCreator.GlobalLevel = LogLevel.Error;            TestLogging_NoOutput(() => _logger.Debug("Test"));            TestLogging_NoOutput(() => _logger.Information("Test"));            TestLogging_NoOutput(() => _logger.Warning("Test"));            TestLogging_Output(() => _logger.Error("Test"));        }        //TODO: Make test to make sure we don't crash on multiple logs with the same name        //TODO: Make sure we don't crash on giving properties        //TODO: Make sure messages are correctly made with properties that are given (at least make sure something was added)                private readonly string _loggerName = typeof(T).FullName!;        private void TestLogging_Output(Action action)        {            Assert.True(                DoesLogOutput(action), "{0} should of outputted but it didn't (Global Level: {1}, Logger Level: {2})", _loggerName, LoggingCreator.GlobalLevel, _logger.LogLevel);        }        private void TestLogging_NoOutput(Action action)        {            Assert.False(                DoesLogOutput(action), "{0} shouldn't of outputted but it did (Global Level: {1}, Logger Level: {2})", _loggerName, LoggingCreator.GlobalLevel, _logger.LogLevel);        }        protected abstract bool DoesLogOutput(Action action);    }}